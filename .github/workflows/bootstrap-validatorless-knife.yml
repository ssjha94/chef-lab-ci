name: Bootstrap Nodes (Validatorless Knife)

on:
  workflow_dispatch:
    inputs:
      provision_with_terraform:
        description: "Provision instances with Terraform before bootstrap"
        required: false
        default: false
        type: boolean
      terraform_workdir:
        description: "Terraform directory (used only when provision_with_terraform=true)"
        required: false
        default: "terraform"
        type: string
      node_count:
        description: "Number of instances to provision (used only when provision_with_terraform=true)"
        required: false
        default: "1"
        type: string
      aws_region:
        description: "AWS region (used only when provision_with_terraform=true)"
        required: false
        default: "ap-northeast-3"
        type: string
      target_hosts:
        description: "Hosts to bootstrap (comma/space/newline separated). Leave empty when using Terraform provisioning."
        required: false
        default: ""
        type: string
      node_name_prefix:
        description: "Prefix used to generate Chef node names"
        required: true
        default: "bootstrap-node"
        type: string
      policy_name:
        description: "Chef policy name to attach during bootstrap"
        required: true
        default: "hello_world"
        type: string
      policy_group:
        description: "Chef policy group to attach during bootstrap"
        required: true
        default: "prod-canary"
        type: string
      ssh_user:
        description: "SSH login user for target nodes"
        required: false
        default: "ubuntu"
        type: string
      ssh_port:
        description: "SSH port for bootstrap"
        required: false
        default: "22"
        type: string
      bootstrap_version:
        description: "Optional Chef Infra Client version (empty means latest stable)"
        required: false
        default: ""
        type: string
      configure_data_collector:
        description: "Configure data collector settings on bootstrapped nodes for Automate reporting"
        required: false
        default: true
        type: boolean

env:
  CHEF_LICENSE: accept-no-persist
  CHEF_WORKSTATION_VERSION: 25.12.1102-1

jobs:
  terraform_provision:
    name: Provision Instances (Optional)
    if: ${{ inputs.provision_with_terraform }}
    runs-on: ubuntu-latest
    outputs:
      target_hosts_json: ${{ steps.tfout.outputs.target_hosts_json }}
    steps:
      - uses: actions/checkout@v4

      - name: Validate Terraform directory exists
        run: |
          set -euo pipefail
          if [ ! -d "${{ inputs.terraform_workdir }}" ]; then
            echo "::error::Terraform workdir '${{ inputs.terraform_workdir }}' does not exist in the repo."
            echo "Set workflow input 'terraform_workdir' to the correct path or add the directory to the repo."
            exit 1
          fi

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: "1.6.0"
          terraform_wrapper: false

      - name: Validate Terraform secrets
        env:
          AWS_SSH_KEY_NAME: ${{ secrets.AWS_SSH_KEY_NAME }}
        run: |
          set -euo pipefail
          if [ -z "${AWS_SSH_KEY_NAME:-}" ]; then
            echo "Missing required secret: AWS_SSH_KEY_NAME"
            exit 1
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ inputs.aws_region }}

      - name: Terraform init
        working-directory: ${{ inputs.terraform_workdir }}
        run: terraform init

      - name: Install SSH key for Terraform provisioner
        env:
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          set -euo pipefail
          if [ -z "${EC2_SSH_KEY:-}" ]; then
            echo "Missing required secret: EC2_SSH_KEY"
            exit 1
          fi
          mkdir -p ~/.ssh
          echo "${EC2_SSH_KEY}" > ~/.ssh/ec2.pem
          chmod 600 ~/.ssh/ec2.pem

      - name: Terraform plan
        working-directory: ${{ inputs.terraform_workdir }}
        run: |
          terraform plan \
            -var="node_count=${{ inputs.node_count }}" \
            -var="policy_group=${{ inputs.policy_group }}" \
            -var="aws_region=${{ inputs.aws_region }}" \
            -var="chef_server_url=${{ secrets.CHEF_SERVER_URL }}" \
            -var="chef_org=${{ secrets.CHEF_ORG }}" \
            -var="ssh_key_name=${{ secrets.AWS_SSH_KEY_NAME }}" \
            -var="run_id=${{ github.run_id }}" \
            -out=tfplan

      - name: Terraform apply
        working-directory: ${{ inputs.terraform_workdir }}
        run: terraform apply -auto-approve tfplan

      - name: Read instance IPs from Terraform output
        id: tfout
        working-directory: ${{ inputs.terraform_workdir }}
        run: |
          set -euo pipefail
          target_hosts_json="$(terraform output -raw instance_ips | tr -d '\r')"
          if [ -z "${target_hosts_json}" ]; then
            echo "No instance_ips output returned by Terraform"
            exit 1
          fi
          {
            echo "target_hosts_json<<EOF"
            echo "${target_hosts_json}"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Wait for SSH readiness on new instances
        run: |
          set -euo pipefail
          raw='${{ steps.tfout.outputs.target_hosts_json }}'
          hosts="$(echo "${raw}" | ruby -rjson -e 'v=JSON.parse(STDIN.read); v=JSON.parse(v) if v.is_a?(String); puts Array(v).join(" ")')"
          for host in ${hosts}; do
            echo "Waiting for SSH on ${host}..."
            for i in $(seq 1 30); do
              if ssh -o BatchMode=yes -o ConnectTimeout=5 -o StrictHostKeyChecking=accept-new \
                     -i ~/.ssh/ec2.pem "${{ inputs.ssh_user }}"@"${host}" 'echo ok' 2>/dev/null; then
                echo "  ${host} is SSH-ready"
                break
              fi
              if [ "$i" -eq 30 ]; then
                echo "::error::Timed out waiting for SSH on ${host}"
                exit 1
              fi
              sleep 10
            done
          done

  resolve_targets:
    name: Resolve Target Hosts
    runs-on: ubuntu-latest
    if: ${{ always() && !failure() && !cancelled() }}
    needs: [terraform_provision]
    outputs:
      hosts_csv: ${{ steps.resolve.outputs.hosts_csv }}
    steps:
      - name: Resolve host list from input or Terraform
        id: resolve
        run: |
          set -euo pipefail
          input_hosts='${{ inputs.target_hosts }}'
          tf_hosts_json='${{ needs.terraform_provision.outputs.target_hosts_json }}'
          hosts_csv=""

          if [ -n "${input_hosts}" ]; then
            hosts_csv="$(printf '%s' "${input_hosts}" | tr ',\n\t' '   ' | xargs -n1 | awk 'NF' | paste -sd, -)"
          elif [ -n "${tf_hosts_json}" ]; then
            hosts_csv="$(printf '%s' "${tf_hosts_json}" | ruby -rjson -e 'v=JSON.parse(STDIN.read); v=JSON.parse(v) if v.is_a?(String); puts Array(v).compact.map(&:to_s).reject(&:empty?).join(",")')"
          fi

          if [ -z "${hosts_csv}" ]; then
            echo "No target hosts resolved. Provide target_hosts or enable provision_with_terraform."
            exit 1
          fi

          echo "hosts_csv=${hosts_csv}" >> "$GITHUB_OUTPUT"
          echo "Resolved hosts: ${hosts_csv}"

  bootstrap:
    name: Validatorless Knife Bootstrap
    runs-on: ubuntu-latest
    if: ${{ always() && !failure() && !cancelled() }}
    needs: [resolve_targets]
    env:
      CHEF_SERVER_URL: ${{ secrets.CHEF_SERVER_URL }}
      CHEF_ORG: ${{ secrets.CHEF_ORG }}
      CHEF_USER: ${{ secrets.CHEF_USER }}
      CHEF_USER_KEY: ${{ secrets.CHEF_USER_KEY }}
      CHEF_SSL_VERIFY: ${{ secrets.CHEF_SSL_VERIFY }}
      SSH_USER: ${{ inputs.ssh_user }}
      SSH_PORT: ${{ inputs.ssh_port }}
      POLICY_NAME: ${{ inputs.policy_name }}
      POLICY_GROUP: ${{ inputs.policy_group }}
      NODE_NAME_PREFIX: ${{ inputs.node_name_prefix }}
      BOOTSTRAP_VERSION: ${{ inputs.bootstrap_version }}
      HOSTS_CSV: ${{ needs.resolve_targets.outputs.hosts_csv }}
      DATA_COLLECTOR_URL: ${{ secrets.DATA_COLLECTOR_URL }}
      DATA_COLLECTOR_TOKEN: ${{ secrets.DATA_COLLECTOR_TOKEN }}
    steps:
      - uses: actions/checkout@v4

      - name: Install Chef Workstation
        run: |
          curl -L https://omnitruck.chef.io/install.sh | sudo bash -s -- -P chef-workstation -v ${CHEF_WORKSTATION_VERSION}

      - name: Configure Chef credentials
        run: |
          mkdir -p ~/.chef
          cat > ~/.chef/knife.rb <<'EOF'
          chef_server_url  ENV['CHEF_SERVER_URL']
          node_name        ENV['CHEF_USER']
          client_key       File.join(ENV['HOME'], '.chef', 'ci-user.pem')
          org_name         ENV['CHEF_ORG'] if ENV['CHEF_ORG']
          ssl_verify_mode  (ENV['CHEF_SSL_VERIFY'] || ':verify_peer')
          knife[:ssh_verify_host_key] = :never
          EOF
          echo "${CHEF_USER_KEY}" > ~/.chef/ci-user.pem
          chmod 600 ~/.chef/ci-user.pem

      - name: Install SSH key
        env:
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          set -euo pipefail
          if [ -z "${EC2_SSH_KEY:-}" ]; then
            echo "Missing required secret: EC2_SSH_KEY"
            exit 1
          fi
          mkdir -p ~/.ssh
          echo "${EC2_SSH_KEY}" > ~/.ssh/ec2.pem
          chmod 600 ~/.ssh/ec2.pem
          printf "Host *\n  StrictHostKeyChecking accept-new\n" > ~/.ssh/config

      - name: Bootstrap hosts
        id: bootstrap
        run: |
          set -euo pipefail
          IFS=',' read -r -a hosts <<< "${HOSTS_CSV}"
          if [ "${#hosts[@]}" -eq 0 ]; then
            echo "No hosts found in HOSTS_CSV"
            exit 1
          fi

          nodes=()
          idx=0
          for host in "${hosts[@]}"; do
            idx=$((idx + 1))
            node_name="${NODE_NAME_PREFIX}-${GITHUB_RUN_ID}-${idx}"
            nodes+=("${node_name}")
            echo "Bootstrapping ${host} as node ${node_name} with ${POLICY_NAME}/${POLICY_GROUP}"

            cmd=(
              knife bootstrap "${host}"
              --connection-protocol ssh
              --connection-user "${SSH_USER}"
              --connection-port "${SSH_PORT}"
              --ssh-identity-file "$HOME/.ssh/ec2.pem"
              --ssh-verify-host-key never
              --sudo
              --yes
              --node-name "${node_name}"
              --policy-name "${POLICY_NAME}"
              --policy-group "${POLICY_GROUP}"
              --chef-license accept-no-persist
            )
            if [ -n "${BOOTSTRAP_VERSION}" ]; then
              cmd+=(--bootstrap-version "${BOOTSTRAP_VERSION}")
            fi

            "${cmd[@]}"
          done

          nodes_csv="$(IFS=,; echo "${nodes[*]}")"
          echo "nodes_csv=${nodes_csv}" >> "$GITHUB_OUTPUT"

      - name: Configure data collector on bootstrapped nodes
        if: ${{ inputs.configure_data_collector }}
        run: |
          set -euo pipefail
          if [ -z "${DATA_COLLECTOR_URL:-}" ] || [ -z "${DATA_COLLECTOR_TOKEN:-}" ]; then
            echo "Missing required secrets for data collector config: DATA_COLLECTOR_URL and/or DATA_COLLECTOR_TOKEN"
            exit 1
          fi

          IFS=',' read -r -a hosts <<< "${HOSTS_CSV}"
          for host in "${hosts[@]}"; do
            echo "Configuring data collector on ${host}"
            ssh \
              -o BatchMode=yes \
              -o ConnectTimeout=20 \
              -o StrictHostKeyChecking=accept-new \
              -i "$HOME/.ssh/ec2.pem" \
              -p "${SSH_PORT}" \
              "${SSH_USER}@${host}" \
              "sudo bash -lc 'grep -q \"^data_collector.server_url \" /etc/chef/client.rb || echo \"data_collector.server_url \\\"${DATA_COLLECTOR_URL}\\\"\" >> /etc/chef/client.rb; grep -q \"^data_collector.token \" /etc/chef/client.rb || echo \"data_collector.token \\\"${DATA_COLLECTOR_TOKEN}\\\"\" >> /etc/chef/client.rb; chef-client -l info'"
          done

      - name: Compliance reporting note
        if: ${{ inputs.configure_data_collector }}
        run: |
          echo "Data collector has been configured on target nodes."
          echo "For nodes to appear in Automate Compliance, your policy/cookbook must execute compliance profiles (InSpec/compliance phase)."

      - name: Verify bootstrapped nodes
        run: |
          set -euo pipefail
          IFS=',' read -r -a nodes <<< "${{ steps.bootstrap.outputs.nodes_csv }}"
          for node in "${nodes[@]}"; do
            knife node show "${node}" -a policy_name -a policy_group -a ipaddress
          done
