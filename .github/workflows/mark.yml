name: Mark

on:
  push:
    branches: [main]
    paths:
      - 'cookbooks/**'
      - 'policyfiles/**'
      - '!cookbooks/**/test/**'
      - '!cookbooks/**/compliance/**'
  workflow_dispatch:
    inputs:
      cookbook:
        description: 'Cookbook to validate (optional, e.g., sample_nginix)'
        required: false
      policyfile:
        description: 'Policyfile to deploy (name/path, e.g., hello_world.rb or sample_nginix)'
        required: false
      enable_automate_health_check:
        description: 'Run Chef Automate node health check after each promotion'
        required: false
        default: true
        type: boolean
      fail_on_automate_failed_nodes:
        description: 'Fail workflow when Automate reports failed nodes (manual runs only)'
        required: false
        default: false
        type: boolean
      automate_additional_filters:
        description: 'Optional extra Automate filters (comma-separated, e.g., chef_server:chef.example)'
        required: false
        default: ''

permissions:
  contents: read

concurrency:
  group: mark-rollout-${{ github.ref }}
  cancel-in-progress: false

env:
  CHEF_LICENSE: accept-silent

jobs:
  detect-cookbooks:
    name: Detect Changed Cookbooks
    runs-on: ubuntu-latest
    outputs:
      cookbooks: ${{ steps.detect.outputs.cookbooks }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect modified cookbooks
        id: detect
        run: |
          INPUT_COOKBOOK="${{ github.event.inputs.cookbook }}"

          if [ -n "$INPUT_COOKBOOK" ]; then
            COOKBOOKS=$(printf '%s\n' "$INPUT_COOKBOOK" | jq -R -s -c 'split("\n")[:-1]')
          else
            if [ "${{ github.event_name }}" = "push" ] && [ -n "${{ github.event.before }}" ] && [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
              DIFF_RANGE="${{ github.event.before }}...${{ github.sha }}"
            else
              DIFF_RANGE="HEAD~1...HEAD"
            fi

            CHANGED_FILES=$(git diff --name-only "$DIFF_RANGE" 2>/dev/null || true)
            COOKBOOKS=$(
              printf '%s\n' "$CHANGED_FILES" \
                | awk -F/ '/^cookbooks\/[^/]+\// {print $2}' \
                | sed '/^$/d' \
                | sort -u \
                | jq -R -s -c 'split("\n")[:-1]'
            )
          fi

          if [ -z "$COOKBOOKS" ] || [ "$COOKBOOKS" = "[]" ]; then
            echo "No cookbooks detected"
            COOKBOOKS='[]'
          fi

          echo "cookbooks=$COOKBOOKS" >> "$GITHUB_OUTPUT"
          echo "Detected cookbooks: $COOKBOOKS"

  validate-versions:
    name: Validate Cookbook Versions
    needs: detect-cookbooks
    if: needs.detect-cookbooks.outputs.cookbooks != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        cookbook: ${{ fromJson(needs.detect-cookbooks.outputs.cookbooks) }}
      fail-fast: false
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate version bump
        working-directory: cookbooks/${{ matrix.cookbook }}
        run: |
          echo "Validating version bump for ${{ matrix.cookbook }}..."

          CURRENT_VERSION=$(grep -E "^version" metadata.rb | head -1 | awk '{print $2}' | tr -d "'\"")
          echo "Current version: $CURRENT_VERSION"

          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "Running on main branch - skipping version comparison"
            exit 0
          fi

          if git show origin/main:cookbooks/${{ matrix.cookbook }}/metadata.rb >/dev/null 2>&1; then
            PREVIOUS_VERSION=$(git show origin/main:cookbooks/${{ matrix.cookbook }}/metadata.rb 2>/dev/null | grep -E "^version" | head -1 | awk '{print $2}' | tr -d "'\"")
            echo "Previous version (main): $PREVIOUS_VERSION"

            if [ "$CURRENT_VERSION" = "$PREVIOUS_VERSION" ]; then
              echo "ERROR: Version was not bumped."
              exit 1
            fi
            echo "Version properly bumped from $PREVIOUS_VERSION to $CURRENT_VERSION"
          else
            echo "New cookbook detected - first version is acceptable"
          fi

  detect-policyfiles:
    name: Detect Policyfiles
    runs-on: ubuntu-latest
    outputs:
      policyfiles: ${{ steps.detect.outputs.policyfiles }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect policyfiles
        id: detect
        run: |
          INPUT_POLICYFILE="${{ github.event.inputs.policyfile }}"

          resolve_policyfile() {
            raw="$1"
            base="$(basename "$raw")"
            stem="${base%.rb}"
            stem="${stem%.lock.json}"

            for candidate in \
              "$raw" \
              "$raw.rb" \
              "$raw.lock.json" \
              "policyfiles/$raw" \
              "policyfiles/$raw.rb" \
              "policyfiles/$raw.lock.json" \
              "policyfiles/$stem.rb" \
              "policyfiles/$stem.lock.json" \
              "cookbooks/$raw/Policyfile.rb" \
              "cookbooks/$raw/Policyfile.lock.json" \
              "cookbooks/$stem/Policyfile.rb" \
              "cookbooks/$stem/Policyfile.lock.json" \
              "$raw/Policyfile.rb" \
              "$raw/Policyfile.lock.json"
            do
              if [ -f "$candidate" ]; then
                echo "$candidate"
                return 0
              fi
            done

            return 1
          }

          if [ -n "$INPUT_POLICYFILE" ]; then
            if ! RESOLVED_POLICYFILE=$(resolve_policyfile "$INPUT_POLICYFILE"); then
              echo "ERROR: Could not resolve policyfile input: $INPUT_POLICYFILE"
              echo "Try one of:"
              echo "  - sample_nginix"
              echo "  - policyfiles/hello_world.rb"
              echo "  - cookbooks/sample_nginix/Policyfile.rb"
              exit 1
            fi
            POLICYFILES=$(printf '%s\n' "$RESOLVED_POLICYFILE" | jq -R -s -c 'split("\n")[:-1]')
          else
            if [ "${{ github.event_name }}" = "push" ] && [ -n "${{ github.event.before }}" ] && [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
              DIFF_RANGE="${{ github.event.before }}...${{ github.sha }}"
            else
              DIFF_RANGE="HEAD~1...HEAD"
            fi

            CHANGED_FILES=$(git diff --name-only "$DIFF_RANGE" 2>/dev/null || true)
            DIRECT_POLICYFILES=$(
              printf '%s\n' "$CHANGED_FILES" \
                | awk '/^policyfiles\/[^/]+\.(rb|lock\.json)$/ || /^cookbooks\/[^/]+\/Policyfile\.(rb|lock\.json)$/' \
                | sed '/^$/d' \
                | sort -u
            )
            COOKBOOK_POLICYFILES=$(
              printf '%s\n' "$CHANGED_FILES" \
                | awk -F/ '/^cookbooks\/[^/]+\// {print $2}' \
                | sed '/^$/d' \
                | sort -u \
                | while read -r cookbook; do
                    candidate="cookbooks/${cookbook}/Policyfile.rb"
                    [ -f "$candidate" ] && echo "$candidate"
                  done \
                | sort -u
            )
            POLICYFILES=$(
              printf '%s\n%s\n' "$DIRECT_POLICYFILES" "$COOKBOOK_POLICYFILES" \
                | sed '/^$/d' \
                | sort -u \
                | jq -R -s -c 'split("\n")[:-1]'
            )
          fi

          if [ -z "$POLICYFILES" ] || [ "$POLICYFILES" = "[]" ]; then
            echo "No policyfiles detected"
            POLICYFILES='[]'
          fi

          echo "policyfiles=$POLICYFILES" >> "$GITHUB_OUTPUT"
          echo "Detected policyfiles: $POLICYFILES"

  build-lockfiles:
    name: Build Policy Lockfiles
    needs: [detect-policyfiles, validate-versions]
    if: needs.detect-policyfiles.outputs.policyfiles != '[]' && (needs.validate-versions.result == 'success' || needs.validate-versions.result == 'skipped')
    runs-on: ubuntu-latest
    strategy:
      matrix:
        policyfile: ${{ fromJson(needs.detect-policyfiles.outputs.policyfiles) }}
      fail-fast: false
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Chef Workstation
        run: |
          curl -L https://omnitruck.chef.io/install.sh | sudo bash -s -- -P chef-workstation -c stable
          echo "/opt/chef-workstation/bin" >> "$GITHUB_PATH"

      - name: Build lockfile
        run: |
          set -euo pipefail
          POLICYFILE="${{ matrix.policyfile }}"
          echo "Building lockfile for: $POLICYFILE"
          [ -f "$POLICYFILE" ] || { echo "ERROR: Policyfile not found at $POLICYFILE"; exit 1; }
          chef install "$POLICYFILE"

      - name: Resolve lockfile metadata
        id: meta
        run: |
          set -euo pipefail
          POLICYFILE="${{ matrix.policyfile }}"
          if [[ "$POLICYFILE" == *.rb ]]; then
            LOCKFILE="${POLICYFILE%.rb}.lock.json"
          else
            LOCKFILE="$POLICYFILE"
          fi
          [ -f "$LOCKFILE" ] || { echo "ERROR: Lockfile not found at $LOCKFILE"; exit 1; }

          SAFE_NAME="$(printf '%s' "$POLICYFILE" | tr '/.' '--' | tr -cd '[:alnum:]_-')"
          [ -n "$SAFE_NAME" ] || SAFE_NAME="policyfile"
          ARTIFACT_NAME="policy-lock-${SAFE_NAME}"

          echo "lockfile_path=$LOCKFILE" >> "$GITHUB_OUTPUT"
          echo "artifact_name=$ARTIFACT_NAME" >> "$GITHUB_OUTPUT"

      - name: Upload lockfile artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.meta.outputs.artifact_name }}
          path: ${{ steps.meta.outputs.lockfile_path }}

  push-dev:
    name: Push Policy (dev)
    needs: [build-lockfiles, detect-policyfiles]
    if: needs.detect-policyfiles.outputs.policyfiles != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        policyfile: ${{ fromJson(needs.detect-policyfiles.outputs.policyfiles) }}
      fail-fast: false
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Chef Workstation
        run: |
          curl -L https://omnitruck.chef.io/install.sh | sudo bash -s -- -P chef-workstation -c stable
          echo "/opt/chef-workstation/bin" >> "$GITHUB_PATH"

      - name: Configure Chef Credentials
        env:
          CHEF_SERVER_URL: ${{ secrets.CHEF_SERVER_URL }}
          CHEF_ORG: ${{ secrets.CHEF_ORG }}
          CHEF_USER: ${{ secrets.CHEF_USER }}
          CHEF_USER_KEY: ${{ secrets.CHEF_USER_KEY }}
          CHEF_SSL_VERIFY: ${{ secrets.CHEF_SSL_VERIFY }}
        run: |
          set -euo pipefail
          for req in CHEF_SERVER_URL CHEF_USER CHEF_USER_KEY; do
            if [ -z "${!req:-}" ]; then
              echo "ERROR: Missing required secret ${req}. Check repository secrets and environment secret overrides."
              exit 1
            fi
          done
          case "${CHEF_SERVER_URL}" in
            http://*|https://*|chefzero://*) ;;
            *)
              echo "ERROR: CHEF_SERVER_URL is invalid. It must start with http://, https://, or chefzero://."
              exit 1
              ;;
          esac
          mkdir -p ~/.chef
          cat > ~/.chef/knife.rb <<'EOF'
          chef_server_url  ENV['CHEF_SERVER_URL']
          node_name        ENV['CHEF_USER']
          client_key       File.join(ENV['HOME'], '.chef', 'ci-user.pem')
          org_name         ENV['CHEF_ORG'] if ENV['CHEF_ORG']
          ssl_verify_mode  (ENV['CHEF_SSL_VERIFY'] || ':verify_peer')
          EOF
          printf '%s' "${CHEF_USER_KEY}" > ~/.chef/ci-user.pem
          chmod 600 ~/.chef/ci-user.pem

      - name: Resolve lockfile metadata
        id: meta
        run: |
          set -euo pipefail
          POLICYFILE="${{ matrix.policyfile }}"
          if [[ "$POLICYFILE" == *.rb ]]; then
            LOCKFILE_PATH="${POLICYFILE%.rb}.lock.json"
          else
            LOCKFILE_PATH="$POLICYFILE"
          fi
          SAFE_NAME="$(printf '%s' "$POLICYFILE" | tr '/.' '--' | tr -cd '[:alnum:]_-')"
          [ -n "$SAFE_NAME" ] || SAFE_NAME="policyfile"
          ARTIFACT_NAME="policy-lock-${SAFE_NAME}"
          echo "lockfile_path=$LOCKFILE_PATH" >> "$GITHUB_OUTPUT"
          echo "artifact_name=$ARTIFACT_NAME" >> "$GITHUB_OUTPUT"

      - name: Download lockfile artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ steps.meta.outputs.artifact_name }}
          path: .

      - name: Resolve downloaded lockfile path
        id: lock
        run: |
          set -euo pipefail
          EXPECTED_PATH="${{ steps.meta.outputs.lockfile_path }}"
          LOCK_BASENAME="$(basename "$EXPECTED_PATH")"
          if [ -f "$EXPECTED_PATH" ]; then
            FOUND="$EXPECTED_PATH"
          else
            FOUND="$(find . -type f -name "$LOCK_BASENAME" | head -n1 || true)"
          fi
          [ -n "$FOUND" ] || { echo "ERROR: Unable to locate lockfile artifact $LOCK_BASENAME"; exit 1; }
          echo "lockfile_path=$FOUND" >> "$GITHUB_OUTPUT"

      - name: Extract policy metadata
        id: policy
        run: |
          set -euo pipefail
          POLICY_NAME="$(ruby -rjson -e 'puts JSON.parse(File.read(ARGV[0]))["name"].to_s' "${{ steps.lock.outputs.lockfile_path }}")"
          [ -n "$POLICY_NAME" ] || { echo "ERROR: policy name missing in lockfile"; exit 1; }
          echo "policy_name=$POLICY_NAME" >> "$GITHUB_OUTPUT"

      - name: Push policy to dev
        run: |
          set -euo pipefail
          echo "Pushing lockfile to dev: ${{ steps.lock.outputs.lockfile_path }}"
          chef push dev "${{ steps.lock.outputs.lockfile_path }}"

      - name: Check Chef Automate health (dev)
        id: automate_dev
        env:
          AUTOMATE_URL: ${{ secrets.AUTOMATE_URL }}
          AUTOMATE_API_TOKEN: ${{ secrets.AUTOMATE_API_TOKEN }}
          POLICY_GROUP: dev
          POLICY_NAME: ${{ steps.policy.outputs.policy_name }}
          ADDITIONAL_FILTERS: ${{ github.event.inputs.automate_additional_filters }}
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.enable_automate_health_check }}" = "false" ]; then
            echo "Automate health check disabled by workflow input."
            echo "success_count=0" >> "$GITHUB_OUTPUT"
            echo "failed_count=0" >> "$GITHUB_OUTPUT"
            echo "total_count=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ -z "${AUTOMATE_URL:-}" ] || [ -z "${AUTOMATE_API_TOKEN:-}" ]; then
            echo "AUTOMATE_URL/AUTOMATE_API_TOKEN not set, skipping Automate health check."
            echo "success_count=0" >> "$GITHUB_OUTPUT"
            echo "failed_count=0" >> "$GITHUB_OUTPUT"
            echo "total_count=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          endpoint="${AUTOMATE_URL%/}/api/v0/cfgmgmt/stats/node_counts"
          filters=("policy_group:${POLICY_GROUP}" "policy_name:${POLICY_NAME}")
          if [ -n "${ADDITIONAL_FILTERS:-}" ]; then
            IFS=',' read -r -a extra_filters <<< "${ADDITIONAL_FILTERS}"
            for raw in "${extra_filters[@]}"; do
              f="$(echo "${raw}" | xargs)"
              [ -n "${f}" ] && filters+=("${f}")
            done
          fi

          query=""
          for f in "${filters[@]}"; do
            encoded="$(ruby -ruri -e 'print URI.encode_www_form_component(ARGV[0])' "${f}")"
            if [ -z "${query}" ]; then
              query="?filter=${encoded}"
            else
              query="${query}&filter=${encoded}"
            fi
          done
          url="${endpoint}${query}"
          echo "Calling Automate node_counts API for ${POLICY_NAME}/${POLICY_GROUP}"
          response="$(curl -fsS -H "api-token: ${AUTOMATE_API_TOKEN}" "${url}")"
          printf '%s\n' "${response}" > automate-node-counts.json

          ruby -rjson <<'RUBY'
          data = JSON.parse(File.read('automate-node-counts.json'))
          counts = Hash.new(0)

          def walk(obj, counts)
            case obj
            when Hash
              if obj['status'] && obj['count']
                counts[obj['status'].to_s.downcase] += obj['count'].to_i
              elsif obj['name'] && obj['count']
                counts[obj['name'].to_s.downcase] += obj['count'].to_i
              else
                obj.each do |k, v|
                  key = k.to_s.downcase
                  if v.is_a?(Numeric) && %w[success failed failure error unreachable skipped total].include?(key)
                    counts[key] += v.to_i
                  else
                    walk(v, counts)
                  end
                end
              end
            when Array
              obj.each { |v| walk(v, counts) }
            end
          end

          walk(data, counts)
          success = counts['success']
          failed = counts['failed'] + counts['failure'] + counts['error'] + counts['unreachable']
          skipped = counts['skipped']
          total = counts['total']
          total = success + failed + skipped if total.zero?

          puts "Automate health summary: success=#{success}, failed=#{failed}, skipped=#{skipped}, total=#{total}"
          File.open(ENV['GITHUB_OUTPUT'], 'a') do |f|
            f.puts "success_count=#{success}"
            f.puts "failed_count=#{failed}"
            f.puts "total_count=#{total}"
          end
          RUBY

      - name: Enforce Automate health gate (dev)
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" != "workflow_dispatch" ] || [ "${{ github.event.inputs.enable_automate_health_check }}" = "false" ] || [ "${{ github.event.inputs.fail_on_automate_failed_nodes }}" = "false" ]; then
            echo "Automate gate not enabled for this run."
            exit 0
          fi

          FAILED="${{ steps.automate_dev.outputs.failed_count }}"
          TOTAL="${{ steps.automate_dev.outputs.total_count }}"
          echo "Automate gate check (dev): failed=${FAILED}, total=${TOTAL}"
          if [ -n "${FAILED}" ] && [ "${FAILED}" -gt 0 ]; then
            echo "ERROR: Automate reported failed nodes in dev."
            exit 1
          fi

  push-test:
    name: Push Policy (test)
    needs: [push-dev, detect-policyfiles]
    if: needs.detect-policyfiles.outputs.policyfiles != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        policyfile: ${{ fromJson(needs.detect-policyfiles.outputs.policyfiles) }}
      fail-fast: false
    environment: test
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Chef Workstation
        run: |
          curl -L https://omnitruck.chef.io/install.sh | sudo bash -s -- -P chef-workstation -c stable
          echo "/opt/chef-workstation/bin" >> "$GITHUB_PATH"

      - name: Configure Chef Credentials
        env:
          CHEF_SERVER_URL: ${{ secrets.CHEF_SERVER_URL }}
          CHEF_ORG: ${{ secrets.CHEF_ORG }}
          CHEF_USER: ${{ secrets.CHEF_USER }}
          CHEF_USER_KEY: ${{ secrets.CHEF_USER_KEY }}
          CHEF_SSL_VERIFY: ${{ secrets.CHEF_SSL_VERIFY }}
        run: |
          set -euo pipefail
          for req in CHEF_SERVER_URL CHEF_USER CHEF_USER_KEY; do
            if [ -z "${!req:-}" ]; then
              echo "ERROR: Missing required secret ${req}. Check repository secrets and environment secret overrides."
              exit 1
            fi
          done
          case "${CHEF_SERVER_URL}" in
            http://*|https://*|chefzero://*) ;;
            *)
              echo "ERROR: CHEF_SERVER_URL is invalid. It must start with http://, https://, or chefzero://."
              exit 1
              ;;
          esac
          mkdir -p ~/.chef
          cat > ~/.chef/knife.rb <<'EOF'
          chef_server_url  ENV['CHEF_SERVER_URL']
          node_name        ENV['CHEF_USER']
          client_key       File.join(ENV['HOME'], '.chef', 'ci-user.pem')
          org_name         ENV['CHEF_ORG'] if ENV['CHEF_ORG']
          ssl_verify_mode  (ENV['CHEF_SSL_VERIFY'] || ':verify_peer')
          EOF
          printf '%s' "${CHEF_USER_KEY}" > ~/.chef/ci-user.pem
          chmod 600 ~/.chef/ci-user.pem

      - name: Resolve lockfile metadata
        id: meta
        run: |
          set -euo pipefail
          POLICYFILE="${{ matrix.policyfile }}"
          if [[ "$POLICYFILE" == *.rb ]]; then
            LOCKFILE_PATH="${POLICYFILE%.rb}.lock.json"
          else
            LOCKFILE_PATH="$POLICYFILE"
          fi
          SAFE_NAME="$(printf '%s' "$POLICYFILE" | tr '/.' '--' | tr -cd '[:alnum:]_-')"
          [ -n "$SAFE_NAME" ] || SAFE_NAME="policyfile"
          ARTIFACT_NAME="policy-lock-${SAFE_NAME}"
          echo "lockfile_path=$LOCKFILE_PATH" >> "$GITHUB_OUTPUT"
          echo "artifact_name=$ARTIFACT_NAME" >> "$GITHUB_OUTPUT"

      - name: Download lockfile artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ steps.meta.outputs.artifact_name }}
          path: .

      - name: Resolve downloaded lockfile path
        id: lock
        run: |
          set -euo pipefail
          EXPECTED_PATH="${{ steps.meta.outputs.lockfile_path }}"
          LOCK_BASENAME="$(basename "$EXPECTED_PATH")"
          if [ -f "$EXPECTED_PATH" ]; then
            FOUND="$EXPECTED_PATH"
          else
            FOUND="$(find . -type f -name "$LOCK_BASENAME" | head -n1 || true)"
          fi
          [ -n "$FOUND" ] || { echo "ERROR: Unable to locate lockfile artifact $LOCK_BASENAME"; exit 1; }
          echo "lockfile_path=$FOUND" >> "$GITHUB_OUTPUT"

      - name: Extract policy metadata
        id: policy
        run: |
          set -euo pipefail
          POLICY_NAME="$(ruby -rjson -e 'puts JSON.parse(File.read(ARGV[0]))["name"].to_s' "${{ steps.lock.outputs.lockfile_path }}")"
          [ -n "$POLICY_NAME" ] || { echo "ERROR: policy name missing in lockfile"; exit 1; }
          echo "policy_name=$POLICY_NAME" >> "$GITHUB_OUTPUT"

      - name: Push policy to test
        run: |
          set -euo pipefail
          echo "Pushing lockfile to test: ${{ steps.lock.outputs.lockfile_path }}"
          chef push test "${{ steps.lock.outputs.lockfile_path }}"

      - name: Check Chef Automate health (test)
        id: automate_test
        env:
          AUTOMATE_URL: ${{ secrets.AUTOMATE_URL }}
          AUTOMATE_API_TOKEN: ${{ secrets.AUTOMATE_API_TOKEN }}
          POLICY_GROUP: test
          POLICY_NAME: ${{ steps.policy.outputs.policy_name }}
          ADDITIONAL_FILTERS: ${{ github.event.inputs.automate_additional_filters }}
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.enable_automate_health_check }}" = "false" ]; then
            echo "Automate health check disabled by workflow input."
            echo "success_count=0" >> "$GITHUB_OUTPUT"
            echo "failed_count=0" >> "$GITHUB_OUTPUT"
            echo "total_count=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ -z "${AUTOMATE_URL:-}" ] || [ -z "${AUTOMATE_API_TOKEN:-}" ]; then
            echo "AUTOMATE_URL/AUTOMATE_API_TOKEN not set, skipping Automate health check."
            echo "success_count=0" >> "$GITHUB_OUTPUT"
            echo "failed_count=0" >> "$GITHUB_OUTPUT"
            echo "total_count=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          endpoint="${AUTOMATE_URL%/}/api/v0/cfgmgmt/stats/node_counts"
          filters=("policy_group:${POLICY_GROUP}" "policy_name:${POLICY_NAME}")
          if [ -n "${ADDITIONAL_FILTERS:-}" ]; then
            IFS=',' read -r -a extra_filters <<< "${ADDITIONAL_FILTERS}"
            for raw in "${extra_filters[@]}"; do
              f="$(echo "${raw}" | xargs)"
              [ -n "${f}" ] && filters+=("${f}")
            done
          fi

          query=""
          for f in "${filters[@]}"; do
            encoded="$(ruby -ruri -e 'print URI.encode_www_form_component(ARGV[0])' "${f}")"
            if [ -z "${query}" ]; then
              query="?filter=${encoded}"
            else
              query="${query}&filter=${encoded}"
            fi
          done
          url="${endpoint}${query}"
          echo "Calling Automate node_counts API for ${POLICY_NAME}/${POLICY_GROUP}"
          response="$(curl -fsS -H "api-token: ${AUTOMATE_API_TOKEN}" "${url}")"
          printf '%s\n' "${response}" > automate-node-counts.json

          ruby -rjson <<'RUBY'
          data = JSON.parse(File.read('automate-node-counts.json'))
          counts = Hash.new(0)

          def walk(obj, counts)
            case obj
            when Hash
              if obj['status'] && obj['count']
                counts[obj['status'].to_s.downcase] += obj['count'].to_i
              elsif obj['name'] && obj['count']
                counts[obj['name'].to_s.downcase] += obj['count'].to_i
              else
                obj.each do |k, v|
                  key = k.to_s.downcase
                  if v.is_a?(Numeric) && %w[success failed failure error unreachable skipped total].include?(key)
                    counts[key] += v.to_i
                  else
                    walk(v, counts)
                  end
                end
              end
            when Array
              obj.each { |v| walk(v, counts) }
            end
          end

          walk(data, counts)
          success = counts['success']
          failed = counts['failed'] + counts['failure'] + counts['error'] + counts['unreachable']
          skipped = counts['skipped']
          total = counts['total']
          total = success + failed + skipped if total.zero?

          puts "Automate health summary: success=#{success}, failed=#{failed}, skipped=#{skipped}, total=#{total}"
          File.open(ENV['GITHUB_OUTPUT'], 'a') do |f|
            f.puts "success_count=#{success}"
            f.puts "failed_count=#{failed}"
            f.puts "total_count=#{total}"
          end
          RUBY

      - name: Enforce Automate health gate (test)
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" != "workflow_dispatch" ] || [ "${{ github.event.inputs.enable_automate_health_check }}" = "false" ] || [ "${{ github.event.inputs.fail_on_automate_failed_nodes }}" = "false" ]; then
            echo "Automate gate not enabled for this run."
            exit 0
          fi

          FAILED="${{ steps.automate_test.outputs.failed_count }}"
          TOTAL="${{ steps.automate_test.outputs.total_count }}"
          echo "Automate gate check (test): failed=${FAILED}, total=${TOTAL}"
          if [ -n "${FAILED}" ] && [ "${FAILED}" -gt 0 ]; then
            echo "ERROR: Automate reported failed nodes in test."
            exit 1
          fi

  push-prod:
    name: Push Policy (prod)
    needs: [push-test, detect-policyfiles]
    if: needs.detect-policyfiles.outputs.policyfiles != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        policyfile: ${{ fromJson(needs.detect-policyfiles.outputs.policyfiles) }}
      fail-fast: false
    environment: prod
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Chef Workstation
        run: |
          curl -L https://omnitruck.chef.io/install.sh | sudo bash -s -- -P chef-workstation -c stable
          echo "/opt/chef-workstation/bin" >> "$GITHUB_PATH"

      - name: Configure Chef Credentials
        env:
          CHEF_SERVER_URL: ${{ secrets.CHEF_SERVER_URL }}
          CHEF_ORG: ${{ secrets.CHEF_ORG }}
          CHEF_USER: ${{ secrets.CHEF_USER }}
          CHEF_USER_KEY: ${{ secrets.CHEF_USER_KEY }}
          CHEF_SSL_VERIFY: ${{ secrets.CHEF_SSL_VERIFY }}
        run: |
          set -euo pipefail
          for req in CHEF_SERVER_URL CHEF_USER CHEF_USER_KEY; do
            if [ -z "${!req:-}" ]; then
              echo "ERROR: Missing required secret ${req}. Check repository secrets and environment secret overrides."
              exit 1
            fi
          done
          case "${CHEF_SERVER_URL}" in
            http://*|https://*|chefzero://*) ;;
            *)
              echo "ERROR: CHEF_SERVER_URL is invalid. It must start with http://, https://, or chefzero://."
              exit 1
              ;;
          esac
          mkdir -p ~/.chef
          cat > ~/.chef/knife.rb <<'EOF'
          chef_server_url  ENV['CHEF_SERVER_URL']
          node_name        ENV['CHEF_USER']
          client_key       File.join(ENV['HOME'], '.chef', 'ci-user.pem')
          org_name         ENV['CHEF_ORG'] if ENV['CHEF_ORG']
          ssl_verify_mode  (ENV['CHEF_SSL_VERIFY'] || ':verify_peer')
          EOF
          printf '%s' "${CHEF_USER_KEY}" > ~/.chef/ci-user.pem
          chmod 600 ~/.chef/ci-user.pem

      - name: Resolve lockfile metadata
        id: meta
        run: |
          set -euo pipefail
          POLICYFILE="${{ matrix.policyfile }}"
          if [[ "$POLICYFILE" == *.rb ]]; then
            LOCKFILE_PATH="${POLICYFILE%.rb}.lock.json"
          else
            LOCKFILE_PATH="$POLICYFILE"
          fi
          SAFE_NAME="$(printf '%s' "$POLICYFILE" | tr '/.' '--' | tr -cd '[:alnum:]_-')"
          [ -n "$SAFE_NAME" ] || SAFE_NAME="policyfile"
          ARTIFACT_NAME="policy-lock-${SAFE_NAME}"
          echo "lockfile_path=$LOCKFILE_PATH" >> "$GITHUB_OUTPUT"
          echo "artifact_name=$ARTIFACT_NAME" >> "$GITHUB_OUTPUT"

      - name: Download lockfile artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ steps.meta.outputs.artifact_name }}
          path: .

      - name: Resolve downloaded lockfile path
        id: lock
        run: |
          set -euo pipefail
          EXPECTED_PATH="${{ steps.meta.outputs.lockfile_path }}"
          LOCK_BASENAME="$(basename "$EXPECTED_PATH")"
          if [ -f "$EXPECTED_PATH" ]; then
            FOUND="$EXPECTED_PATH"
          else
            FOUND="$(find . -type f -name "$LOCK_BASENAME" | head -n1 || true)"
          fi
          [ -n "$FOUND" ] || { echo "ERROR: Unable to locate lockfile artifact $LOCK_BASENAME"; exit 1; }
          echo "lockfile_path=$FOUND" >> "$GITHUB_OUTPUT"

      - name: Extract policy metadata
        id: policy
        run: |
          set -euo pipefail
          POLICY_NAME="$(ruby -rjson -e 'puts JSON.parse(File.read(ARGV[0]))["name"].to_s' "${{ steps.lock.outputs.lockfile_path }}")"
          [ -n "$POLICY_NAME" ] || { echo "ERROR: policy name missing in lockfile"; exit 1; }
          echo "policy_name=$POLICY_NAME" >> "$GITHUB_OUTPUT"

      - name: Push policy to prod
        run: |
          set -euo pipefail
          echo "Pushing lockfile to prod: ${{ steps.lock.outputs.lockfile_path }}"
          chef push prod "${{ steps.lock.outputs.lockfile_path }}"

      - name: Check Chef Automate health (prod)
        id: automate_prod
        env:
          AUTOMATE_URL: ${{ secrets.AUTOMATE_URL }}
          AUTOMATE_API_TOKEN: ${{ secrets.AUTOMATE_API_TOKEN }}
          POLICY_GROUP: prod
          POLICY_NAME: ${{ steps.policy.outputs.policy_name }}
          ADDITIONAL_FILTERS: ${{ github.event.inputs.automate_additional_filters }}
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.enable_automate_health_check }}" = "false" ]; then
            echo "Automate health check disabled by workflow input."
            echo "success_count=0" >> "$GITHUB_OUTPUT"
            echo "failed_count=0" >> "$GITHUB_OUTPUT"
            echo "total_count=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ -z "${AUTOMATE_URL:-}" ] || [ -z "${AUTOMATE_API_TOKEN:-}" ]; then
            echo "AUTOMATE_URL/AUTOMATE_API_TOKEN not set, skipping Automate health check."
            echo "success_count=0" >> "$GITHUB_OUTPUT"
            echo "failed_count=0" >> "$GITHUB_OUTPUT"
            echo "total_count=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          endpoint="${AUTOMATE_URL%/}/api/v0/cfgmgmt/stats/node_counts"
          filters=("policy_group:${POLICY_GROUP}" "policy_name:${POLICY_NAME}")
          if [ -n "${ADDITIONAL_FILTERS:-}" ]; then
            IFS=',' read -r -a extra_filters <<< "${ADDITIONAL_FILTERS}"
            for raw in "${extra_filters[@]}"; do
              f="$(echo "${raw}" | xargs)"
              [ -n "${f}" ] && filters+=("${f}")
            done
          fi

          query=""
          for f in "${filters[@]}"; do
            encoded="$(ruby -ruri -e 'print URI.encode_www_form_component(ARGV[0])' "${f}")"
            if [ -z "${query}" ]; then
              query="?filter=${encoded}"
            else
              query="${query}&filter=${encoded}"
            fi
          done
          url="${endpoint}${query}"
          echo "Calling Automate node_counts API for ${POLICY_NAME}/${POLICY_GROUP}"
          response="$(curl -fsS -H "api-token: ${AUTOMATE_API_TOKEN}" "${url}")"
          printf '%s\n' "${response}" > automate-node-counts.json

          ruby -rjson <<'RUBY'
          data = JSON.parse(File.read('automate-node-counts.json'))
          counts = Hash.new(0)

          def walk(obj, counts)
            case obj
            when Hash
              if obj['status'] && obj['count']
                counts[obj['status'].to_s.downcase] += obj['count'].to_i
              elsif obj['name'] && obj['count']
                counts[obj['name'].to_s.downcase] += obj['count'].to_i
              else
                obj.each do |k, v|
                  key = k.to_s.downcase
                  if v.is_a?(Numeric) && %w[success failed failure error unreachable skipped total].include?(key)
                    counts[key] += v.to_i
                  else
                    walk(v, counts)
                  end
                end
              end
            when Array
              obj.each { |v| walk(v, counts) }
            end
          end

          walk(data, counts)
          success = counts['success']
          failed = counts['failed'] + counts['failure'] + counts['error'] + counts['unreachable']
          skipped = counts['skipped']
          total = counts['total']
          total = success + failed + skipped if total.zero?

          puts "Automate health summary: success=#{success}, failed=#{failed}, skipped=#{skipped}, total=#{total}"
          File.open(ENV['GITHUB_OUTPUT'], 'a') do |f|
            f.puts "success_count=#{success}"
            f.puts "failed_count=#{failed}"
            f.puts "total_count=#{total}"
          end
          RUBY

      - name: Enforce Automate health gate (prod)
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" != "workflow_dispatch" ] || [ "${{ github.event.inputs.enable_automate_health_check }}" = "false" ] || [ "${{ github.event.inputs.fail_on_automate_failed_nodes }}" = "false" ]; then
            echo "Automate gate not enabled for this run."
            exit 0
          fi

          FAILED="${{ steps.automate_prod.outputs.failed_count }}"
          TOTAL="${{ steps.automate_prod.outputs.total_count }}"
          echo "Automate gate check (prod): failed=${FAILED}, total=${TOTAL}"
          if [ -n "${FAILED}" ] && [ "${FAILED}" -gt 0 ]; then
            echo "ERROR: Automate reported failed nodes in prod."
            exit 1
          fi
