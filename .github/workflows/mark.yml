name: Mark

on:
  push:
    branches: [main]
    paths:
      - 'cookbooks/**'
      - 'policyfiles/**'
      - '!cookbooks/**/test/**'
      - '!cookbooks/**/compliance/**'
  workflow_dispatch:
    inputs:
      cookbook:
        description: 'Cookbook to validate (optional, e.g., base_linux)'
        required: false
      policyfile:
        description: 'Policyfile to deploy (name/path, e.g., hello_world.rb or sample_nginix)'
        required: false
      canary_delay_hours:
        description: 'Delay before canary promotion (hours)'
        required: false
        default: '2'
      prod_delay_hours:
        description: 'Delay before prod promotion (hours)'
        required: false
        default: '24'

env:
  CHEF_LICENSE: accept-silent

jobs:
  detect-cookbooks:
    name: Detect Changed Cookbooks
    runs-on: ubuntu-latest
    outputs:
      cookbooks: ${{ steps.detect.outputs.cookbooks }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect modified cookbooks
        id: detect
        run: |
          INPUT_COOKBOOK="${{ github.event.inputs.cookbook }}"

          if [ -n "$INPUT_COOKBOOK" ]; then
            COOKBOOKS=$(printf '%s\n' "$INPUT_COOKBOOK" | jq -R -s -c 'split("\n")[:-1]')
          else
            if [ "${{ github.event_name }}" = "push" ] && [ -n "${{ github.event.before }}" ] && [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
              DIFF_RANGE="${{ github.event.before }}...${{ github.sha }}"
            else
              DIFF_RANGE="HEAD~1...HEAD"
            fi

            CHANGED_FILES=$(git diff --name-only "$DIFF_RANGE" 2>/dev/null || true)
            COOKBOOKS=$(
              printf '%s\n' "$CHANGED_FILES" \
                | awk -F/ '/^cookbooks\/[^/]+\// {print $2}' \
                | sed '/^$/d' \
                | sort -u \
                | jq -R -s -c 'split("\n")[:-1]'
            )
          fi

          if [ -z "$COOKBOOKS" ] || [ "$COOKBOOKS" == "[]" ]; then
            echo "No cookbooks detected"
            COOKBOOKS='[]'
          fi

          echo "cookbooks=$COOKBOOKS" >> $GITHUB_OUTPUT
          echo "Detected cookbooks: $COOKBOOKS"

  validate-versions:
    name: Validate Cookbook Versions
    needs: detect-cookbooks
    if: needs.detect-cookbooks.outputs.cookbooks != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        cookbook: ${{ fromJson(needs.detect-cookbooks.outputs.cookbooks) }}
      fail-fast: false
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate version bump
        working-directory: cookbooks/${{ matrix.cookbook }}
        run: |
          echo "Validating version bump for ${{ matrix.cookbook }}..."

          CURRENT_VERSION=$(grep -E "^version" metadata.rb | head -1 | awk '{print $2}' | tr -d "'\"")
          echo "Current version: $CURRENT_VERSION"

          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "Running on main branch - skipping version comparison"
            echo "Version validation skipped for direct main push"
            exit 0
          fi

          if git show origin/main:cookbooks/${{ matrix.cookbook }}/metadata.rb >/dev/null 2>&1; then
            PREVIOUS_VERSION=$(git show origin/main:cookbooks/${{ matrix.cookbook }}/metadata.rb 2>/dev/null | grep -E "^version" | head -1 | awk '{print $2}' | tr -d "'\"")
            echo "Previous version (main): $PREVIOUS_VERSION"

            if [ "$CURRENT_VERSION" == "$PREVIOUS_VERSION" ]; then
              echo "ERROR: Version was not bumped!"
              echo "Current: $CURRENT_VERSION"
              echo "Previous: $PREVIOUS_VERSION"
              echo "Please bump the version in metadata.rb before pushing"
              exit 1
            else
              echo "Version properly bumped from $PREVIOUS_VERSION to $CURRENT_VERSION"
            fi
          else
            echo "New cookbook detected - this will be version $CURRENT_VERSION"
            echo "First version is acceptable"
          fi

  detect-policyfiles:
    name: Detect Policyfiles
    runs-on: ubuntu-latest
    outputs:
      policyfiles: ${{ steps.detect.outputs.policyfiles }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect policyfiles
        id: detect
        run: |
          INPUT_POLICYFILE="${{ github.event.inputs.policyfile }}"

          resolve_policyfile() {
            local raw="$1"
            local base stem
            base="$(basename "$raw")"
            stem="${base%.rb}"

            for candidate in \
              "$raw" \
              "$raw.rb" \
              "policyfiles/$raw" \
              "policyfiles/$raw.rb" \
              "policyfiles/$stem.rb" \
              "cookbooks/$raw/Policyfile.rb" \
              "cookbooks/$stem/Policyfile.rb" \
              "cookbooks/$raw/Policyfile.lock.json" \
              "cookbooks/$stem/Policyfile.lock.json" \
              "$raw/Policyfile.rb"
            do
              if [ -f "$candidate" ]; then
                echo "$candidate"
                return 0
              fi
            done

            return 1
          }

          if [ -n "$INPUT_POLICYFILE" ]; then
            # Accept full path, root policyfiles name, cookbook name, or cookbook path.
            if ! RESOLVED_POLICYFILE=$(resolve_policyfile "$INPUT_POLICYFILE"); then
              echo "ERROR: Could not resolve policyfile input: $INPUT_POLICYFILE"
              echo "Try one of:"
              echo "  - hello_world.rb"
              echo "  - policyfiles/hello_world.rb"
              echo "  - sample_nginix"
              echo "  - cookbooks/sample_nginix/Policyfile.rb"
              exit 1
            fi

            POLICYFILES=$(printf '%s\n' "$RESOLVED_POLICYFILE" | jq -R -s -c 'split("\n")[:-1]')
          else
            if [ "${{ github.event_name }}" = "push" ] && [ -n "${{ github.event.before }}" ] && [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
              DIFF_RANGE="${{ github.event.before }}...${{ github.sha }}"
            else
              DIFF_RANGE="HEAD~1...HEAD"
            fi

            CHANGED_FILES=$(git diff --name-only "$DIFF_RANGE" 2>/dev/null || true)
            DIRECT_POLICYFILES=$(
              printf '%s\n' "$CHANGED_FILES" \
                | awk '/^policyfiles\/[^/]+\.rb$/ || /^cookbooks\/[^/]+\/Policyfile\.rb$/' \
                | sed '/^$/d' \
                | sort -u
            )
            COOKBOOK_POLICYFILES=$(
              printf '%s\n' "$CHANGED_FILES" \
                | awk -F/ '/^cookbooks\/[^/]+\// {print $2}' \
                | sed '/^$/d' \
                | sort -u \
                | while read -r cookbook; do
                    candidate="cookbooks/${cookbook}/Policyfile.rb"
                    [ -f "$candidate" ] && echo "$candidate"
                  done \
                | sort -u
            )
            POLICYFILES=$(
              printf '%s\n%s\n' "$DIRECT_POLICYFILES" "$COOKBOOK_POLICYFILES" \
                | sed '/^$/d' \
                | sort -u \
                | jq -R -s -c 'split("\n")[:-1]'
            )
          fi

          if [ -z "$POLICYFILES" ] || [ "$POLICYFILES" == "[]" ]; then
            echo "No policyfiles detected"
            POLICYFILES='[]'
          fi

          echo "policyfiles=$POLICYFILES" >> $GITHUB_OUTPUT
          echo "Detected policyfiles: $POLICYFILES"

  build-lockfiles:
    name: Build Policy Lockfiles
    needs: [detect-policyfiles, validate-versions]
    if: needs.detect-policyfiles.outputs.policyfiles != '[]' && (needs.validate-versions.result == 'success' || needs.validate-versions.result == 'skipped')
    runs-on: ubuntu-latest
    strategy:
      matrix:
        policyfile: ${{ fromJson(needs.detect-policyfiles.outputs.policyfiles) }}
      fail-fast: false
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Chef Workstation
        run: |
          echo "Installing Chef Workstation..."
          curl -L https://omnitruck.chef.io/install.sh | sudo bash -s -- -P chef-workstation -c stable
          echo "/opt/chef-workstation/bin" >> $GITHUB_PATH
          echo "Chef Workstation ready"

      - name: Build lockfile
        run: |
          set -euo pipefail
          POLICYFILE="${{ matrix.policyfile }}"
          echo "Building lockfile for $POLICYFILE"
          if [ ! -f "$POLICYFILE" ]; then
            echo "ERROR: Policyfile not found at path $POLICYFILE"
            exit 1
          fi
          chef install "$POLICYFILE"

  push-dev:
    name: Push Policy (dev)
    needs: [build-lockfiles, detect-policyfiles]
    if: needs.detect-policyfiles.outputs.policyfiles != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        policyfile: ${{ fromJson(needs.detect-policyfiles.outputs.policyfiles) }}
      fail-fast: false
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Chef Workstation
        run: |
          echo "Installing Chef Workstation..."
          curl -L https://omnitruck.chef.io/install.sh | sudo bash -s -- -P chef-workstation -c stable
          echo "/opt/chef-workstation/bin" >> $GITHUB_PATH
          echo "Chef Workstation ready"

      - name: Configure Chef Credentials
        env:
          CHEF_SERVER_URL: ${{ secrets.CHEF_SERVER_URL }}
          CHEF_ORG: ${{ secrets.CHEF_ORG }}
          CHEF_USER: ${{ secrets.CHEF_USER }}
          CHEF_USER_KEY: ${{ secrets.CHEF_USER_KEY }}
          CHEF_SSL_VERIFY: ${{ secrets.CHEF_SSL_VERIFY }}
        run: |
          mkdir -p ~/.chef
          cat > ~/.chef/knife.rb <<'EOF'
          chef_server_url  ENV['CHEF_SERVER_URL']
          node_name        ENV['CHEF_USER']
          client_key       File.join(ENV['HOME'], '.chef', 'ci-user.pem')
          org_name         ENV['CHEF_ORG'] if ENV['CHEF_ORG']
          ssl_verify_mode  (ENV['CHEF_SSL_VERIFY'] || ':verify_peer')
          EOF
          printf '%s' "${CHEF_USER_KEY}" > ~/.chef/ci-user.pem
          chmod 600 ~/.chef/ci-user.pem
          echo "Chef credentials configured with SSL verification"

      - name: Build lockfile for push
        run: |
          set -euo pipefail
          POLICYFILE="${{ matrix.policyfile }}"
          echo "Building lockfile for push: $POLICYFILE"
          if [ ! -f "$POLICYFILE" ]; then
            echo "ERROR: Policyfile not found at path $POLICYFILE"
            exit 1
          fi
          chef install "$POLICYFILE"

      - name: Push policy to dev
        run: |
          set -euo pipefail
          POLICYFILE="${{ matrix.policyfile }}"
          if [[ "$POLICYFILE" == *.rb ]]; then
            PUSH_TARGET="${POLICYFILE%.rb}.lock.json"
          else
            PUSH_TARGET="$POLICYFILE"
          fi
          echo "Pushing policy to dev: $PUSH_TARGET"
          chef push dev "$PUSH_TARGET"
          echo "Dev push complete"

  push-canary:
    name: Push Policy (canary)
    needs: [push-dev, detect-policyfiles]
    if: needs.detect-policyfiles.outputs.policyfiles != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        policyfile: ${{ fromJson(needs.detect-policyfiles.outputs.policyfiles) }}
      fail-fast: false
    env:
      CANARY_DELAY_HOURS: ${{ github.event.inputs.canary_delay_hours || '2' }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Chef Workstation
        run: |
          echo "Installing Chef Workstation..."
          curl -L https://omnitruck.chef.io/install.sh | sudo bash -s -- -P chef-workstation -c stable
          echo "/opt/chef-workstation/bin" >> $GITHUB_PATH
          echo "Chef Workstation ready"

      - name: Configure Chef Credentials
        env:
          CHEF_SERVER_URL: ${{ secrets.CHEF_SERVER_URL }}
          CHEF_ORG: ${{ secrets.CHEF_ORG }}
          CHEF_USER: ${{ secrets.CHEF_USER }}
          CHEF_USER_KEY: ${{ secrets.CHEF_USER_KEY }}
          CHEF_SSL_VERIFY: ${{ secrets.CHEF_SSL_VERIFY }}
        run: |
          mkdir -p ~/.chef
          cat > ~/.chef/knife.rb <<'EOF'
          chef_server_url  ENV['CHEF_SERVER_URL']
          node_name        ENV['CHEF_USER']
          client_key       File.join(ENV['HOME'], '.chef', 'ci-user.pem')
          org_name         ENV['CHEF_ORG'] if ENV['CHEF_ORG']
          ssl_verify_mode  (ENV['CHEF_SSL_VERIFY'] || ':verify_peer')
          EOF
          printf '%s' "${CHEF_USER_KEY}" > ~/.chef/ci-user.pem
          chmod 600 ~/.chef/ci-user.pem
          echo "Chef credentials configured with SSL verification"

      - name: Build lockfile for push
        run: |
          set -euo pipefail
          POLICYFILE="${{ matrix.policyfile }}"
          echo "Building lockfile for push: $POLICYFILE"
          if [ ! -f "$POLICYFILE" ]; then
            echo "ERROR: Policyfile not found at path $POLICYFILE"
            exit 1
          fi
          chef install "$POLICYFILE"

      - name: Wait before canary promotion
        if: env.CANARY_DELAY_HOURS != '0'
        run: |
          set -euo pipefail
          echo "Waiting ${CANARY_DELAY_HOURS} hour(s) before canary promotion..."
          sleep $((CANARY_DELAY_HOURS * 3600))

      - name: Push policy to canary
        run: |
          set -euo pipefail
          POLICYFILE="${{ matrix.policyfile }}"
          if [[ "$POLICYFILE" == *.rb ]]; then
            PUSH_TARGET="${POLICYFILE%.rb}.lock.json"
          else
            PUSH_TARGET="$POLICYFILE"
          fi
          echo "Pushing policy to canary: $PUSH_TARGET"
          chef push canary "$PUSH_TARGET"
          echo "Canary push complete"

  push-prod:
    name: Push Policy (prod)
    needs: [push-canary, detect-policyfiles]
    if: needs.detect-policyfiles.outputs.policyfiles != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        policyfile: ${{ fromJson(needs.detect-policyfiles.outputs.policyfiles) }}
      fail-fast: false
    env:
      PROD_DELAY_HOURS: ${{ github.event.inputs.prod_delay_hours || '24' }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Chef Workstation
        run: |
          echo "Installing Chef Workstation..."
          curl -L https://omnitruck.chef.io/install.sh | sudo bash -s -- -P chef-workstation -c stable
          echo "/opt/chef-workstation/bin" >> $GITHUB_PATH
          echo "Chef Workstation ready"

      - name: Configure Chef Credentials
        env:
          CHEF_SERVER_URL: ${{ secrets.CHEF_SERVER_URL }}
          CHEF_ORG: ${{ secrets.CHEF_ORG }}
          CHEF_USER: ${{ secrets.CHEF_USER }}
          CHEF_USER_KEY: ${{ secrets.CHEF_USER_KEY }}
          CHEF_SSL_VERIFY: ${{ secrets.CHEF_SSL_VERIFY }}
        run: |
          mkdir -p ~/.chef
          cat > ~/.chef/knife.rb <<'EOF'
          chef_server_url  ENV['CHEF_SERVER_URL']
          node_name        ENV['CHEF_USER']
          client_key       File.join(ENV['HOME'], '.chef', 'ci-user.pem')
          org_name         ENV['CHEF_ORG'] if ENV['CHEF_ORG']
          ssl_verify_mode  (ENV['CHEF_SSL_VERIFY'] || ':verify_peer')
          EOF
          printf '%s' "${CHEF_USER_KEY}" > ~/.chef/ci-user.pem
          chmod 600 ~/.chef/ci-user.pem
          echo "Chef credentials configured with SSL verification"

      - name: Build lockfile for push
        run: |
          set -euo pipefail
          POLICYFILE="${{ matrix.policyfile }}"
          echo "Building lockfile for push: $POLICYFILE"
          if [ ! -f "$POLICYFILE" ]; then
            echo "ERROR: Policyfile not found at path $POLICYFILE"
            exit 1
          fi
          chef install "$POLICYFILE"

      - name: Wait before prod promotion
        if: env.PROD_DELAY_HOURS != '0'
        run: |
          set -euo pipefail
          echo "Waiting ${PROD_DELAY_HOURS} hour(s) before prod promotion..."
          sleep $((PROD_DELAY_HOURS * 3600))

      - name: Push policy to prod
        run: |
          set -euo pipefail
          POLICYFILE="${{ matrix.policyfile }}"
          if [[ "$POLICYFILE" == *.rb ]]; then
            PUSH_TARGET="${POLICYFILE%.rb}.lock.json"
          else
            PUSH_TARGET="$POLICYFILE"
          fi
          echo "Pushing policy to prod: $PUSH_TARGET"
          chef push prod "$PUSH_TARGET"
          echo "Prod push complete"
