name: Mark

on:
  push:
    branches: [main]
    paths:
      - 'cookbooks/**'
      - 'policyfiles/**'
      - '!cookbooks/**/test/**'
      - '!cookbooks/**/compliance/**'
  workflow_dispatch:
    inputs:
      cookbook:
        description: 'Cookbook to validate (optional, e.g., sample_nginix)'
        required: false
      policyfile:
        description: 'Policyfile to deploy (name/path, e.g., hello_world.rb or sample_nginix)'
        required: false

permissions:
  contents: read

concurrency:
  group: mark-rollout-${{ github.ref }}
  cancel-in-progress: false

env:
  CHEF_LICENSE: accept-silent

jobs:
  detect-cookbooks:
    name: Detect Changed Cookbooks
    runs-on: ubuntu-latest
    outputs:
      cookbooks: ${{ steps.detect.outputs.cookbooks }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect modified cookbooks
        id: detect
        run: |
          INPUT_COOKBOOK="${{ github.event.inputs.cookbook }}"

          if [ -n "$INPUT_COOKBOOK" ]; then
            COOKBOOKS=$(printf '%s\n' "$INPUT_COOKBOOK" | jq -R -s -c 'split("\n")[:-1]')
          else
            if [ "${{ github.event_name }}" = "push" ] && [ -n "${{ github.event.before }}" ] && [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
              DIFF_RANGE="${{ github.event.before }}...${{ github.sha }}"
            else
              DIFF_RANGE="HEAD~1...HEAD"
            fi

            CHANGED_FILES=$(git diff --name-only "$DIFF_RANGE" 2>/dev/null || true)
            COOKBOOKS=$(
              printf '%s\n' "$CHANGED_FILES" \
                | awk -F/ '/^cookbooks\/[^/]+\// {print $2}' \
                | sed '/^$/d' \
                | sort -u \
                | jq -R -s -c 'split("\n")[:-1]'
            )
          fi

          if [ -z "$COOKBOOKS" ] || [ "$COOKBOOKS" = "[]" ]; then
            echo "No cookbooks detected"
            COOKBOOKS='[]'
          fi

          echo "cookbooks=$COOKBOOKS" >> "$GITHUB_OUTPUT"
          echo "Detected cookbooks: $COOKBOOKS"

  validate-versions:
    name: Validate Cookbook Versions
    needs: detect-cookbooks
    if: needs.detect-cookbooks.outputs.cookbooks != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        cookbook: ${{ fromJson(needs.detect-cookbooks.outputs.cookbooks) }}
      fail-fast: false
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate version bump
        working-directory: cookbooks/${{ matrix.cookbook }}
        run: |
          echo "Validating version bump for ${{ matrix.cookbook }}..."

          CURRENT_VERSION=$(grep -E "^version" metadata.rb | head -1 | awk '{print $2}' | tr -d "'\"")
          echo "Current version: $CURRENT_VERSION"

          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "Running on main branch - skipping version comparison"
            exit 0
          fi

          if git show origin/main:cookbooks/${{ matrix.cookbook }}/metadata.rb >/dev/null 2>&1; then
            PREVIOUS_VERSION=$(git show origin/main:cookbooks/${{ matrix.cookbook }}/metadata.rb 2>/dev/null | grep -E "^version" | head -1 | awk '{print $2}' | tr -d "'\"")
            echo "Previous version (main): $PREVIOUS_VERSION"

            if [ "$CURRENT_VERSION" = "$PREVIOUS_VERSION" ]; then
              echo "ERROR: Version was not bumped."
              exit 1
            fi
            echo "Version properly bumped from $PREVIOUS_VERSION to $CURRENT_VERSION"
          else
            echo "New cookbook detected - first version is acceptable"
          fi

  detect-policyfiles:
    name: Detect Policyfiles
    runs-on: ubuntu-latest
    outputs:
      policyfiles: ${{ steps.detect.outputs.policyfiles }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect policyfiles
        id: detect
        run: |
          INPUT_POLICYFILE="${{ github.event.inputs.policyfile }}"

          resolve_policyfile() {
            raw="$1"
            base="$(basename "$raw")"
            stem="${base%.rb}"
            stem="${stem%.lock.json}"

            for candidate in \
              "$raw" \
              "$raw.rb" \
              "$raw.lock.json" \
              "policyfiles/$raw" \
              "policyfiles/$raw.rb" \
              "policyfiles/$raw.lock.json" \
              "policyfiles/$stem.rb" \
              "policyfiles/$stem.lock.json" \
              "cookbooks/$raw/Policyfile.rb" \
              "cookbooks/$raw/Policyfile.lock.json" \
              "cookbooks/$stem/Policyfile.rb" \
              "cookbooks/$stem/Policyfile.lock.json" \
              "$raw/Policyfile.rb" \
              "$raw/Policyfile.lock.json"
            do
              if [ -f "$candidate" ]; then
                echo "$candidate"
                return 0
              fi
            done

            return 1
          }

          if [ -n "$INPUT_POLICYFILE" ]; then
            if ! RESOLVED_POLICYFILE=$(resolve_policyfile "$INPUT_POLICYFILE"); then
              echo "ERROR: Could not resolve policyfile input: $INPUT_POLICYFILE"
              echo "Try one of:"
              echo "  - sample_nginix"
              echo "  - policyfiles/hello_world.rb"
              echo "  - cookbooks/sample_nginix/Policyfile.rb"
              exit 1
            fi
            POLICYFILES=$(printf '%s\n' "$RESOLVED_POLICYFILE" | jq -R -s -c 'split("\n")[:-1]')
          else
            if [ "${{ github.event_name }}" = "push" ] && [ -n "${{ github.event.before }}" ] && [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
              DIFF_RANGE="${{ github.event.before }}...${{ github.sha }}"
            else
              DIFF_RANGE="HEAD~1...HEAD"
            fi

            CHANGED_FILES=$(git diff --name-only "$DIFF_RANGE" 2>/dev/null || true)
            DIRECT_POLICYFILES=$(
              printf '%s\n' "$CHANGED_FILES" \
                | awk '/^policyfiles\/[^/]+\.(rb|lock\.json)$/ || /^cookbooks\/[^/]+\/Policyfile\.(rb|lock\.json)$/' \
                | sed '/^$/d' \
                | sort -u
            )
            COOKBOOK_POLICYFILES=$(
              printf '%s\n' "$CHANGED_FILES" \
                | awk -F/ '/^cookbooks\/[^/]+\// {print $2}' \
                | sed '/^$/d' \
                | sort -u \
                | while read -r cookbook; do
                    candidate="cookbooks/${cookbook}/Policyfile.rb"
                    [ -f "$candidate" ] && echo "$candidate"
                  done \
                | sort -u
            )
            POLICYFILES=$(
              printf '%s\n%s\n' "$DIRECT_POLICYFILES" "$COOKBOOK_POLICYFILES" \
                | sed '/^$/d' \
                | sort -u \
                | jq -R -s -c 'split("\n")[:-1]'
            )
          fi

          if [ -z "$POLICYFILES" ] || [ "$POLICYFILES" = "[]" ]; then
            echo "No policyfiles detected"
            POLICYFILES='[]'
          fi

          echo "policyfiles=$POLICYFILES" >> "$GITHUB_OUTPUT"
          echo "Detected policyfiles: $POLICYFILES"

  build-lockfiles:
    name: Build Policy Lockfiles
    needs: [detect-policyfiles, validate-versions]
    if: needs.detect-policyfiles.outputs.policyfiles != '[]' && (needs.validate-versions.result == 'success' || needs.validate-versions.result == 'skipped')
    runs-on: ubuntu-latest
    strategy:
      matrix:
        policyfile: ${{ fromJson(needs.detect-policyfiles.outputs.policyfiles) }}
      fail-fast: false
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Chef Workstation
        run: |
          curl -L https://omnitruck.chef.io/install.sh | sudo bash -s -- -P chef-workstation -c stable
          echo "/opt/chef-workstation/bin" >> "$GITHUB_PATH"

      - name: Build lockfile
        run: |
          set -euo pipefail
          POLICYFILE="${{ matrix.policyfile }}"
          echo "Building lockfile for: $POLICYFILE"
          [ -f "$POLICYFILE" ] || { echo "ERROR: Policyfile not found at $POLICYFILE"; exit 1; }
          chef install "$POLICYFILE"

      - name: Resolve lockfile metadata
        id: meta
        run: |
          set -euo pipefail
          POLICYFILE="${{ matrix.policyfile }}"
          if [[ "$POLICYFILE" == *.rb ]]; then
            LOCKFILE="${POLICYFILE%.rb}.lock.json"
          else
            LOCKFILE="$POLICYFILE"
          fi
          [ -f "$LOCKFILE" ] || { echo "ERROR: Lockfile not found at $LOCKFILE"; exit 1; }

          SAFE_NAME="$(printf '%s' "$POLICYFILE" | tr '/.' '--' | tr -cd '[:alnum:]_-')"
          [ -n "$SAFE_NAME" ] || SAFE_NAME="policyfile"
          ARTIFACT_NAME="policy-lock-${SAFE_NAME}"

          echo "lockfile_path=$LOCKFILE" >> "$GITHUB_OUTPUT"
          echo "artifact_name=$ARTIFACT_NAME" >> "$GITHUB_OUTPUT"

      - name: Upload lockfile artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.meta.outputs.artifact_name }}
          path: ${{ steps.meta.outputs.lockfile_path }}

  push-dev:
    name: Push Policy (dev)
    needs: [build-lockfiles, detect-policyfiles]
    if: needs.detect-policyfiles.outputs.policyfiles != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        policyfile: ${{ fromJson(needs.detect-policyfiles.outputs.policyfiles) }}
      fail-fast: false
    environment: dev
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Chef Workstation
        run: |
          curl -L https://omnitruck.chef.io/install.sh | sudo bash -s -- -P chef-workstation -c stable
          echo "/opt/chef-workstation/bin" >> "$GITHUB_PATH"

      - name: Configure Chef Credentials
        env:
          CHEF_SERVER_URL: ${{ secrets.CHEF_SERVER_URL }}
          CHEF_ORG: ${{ secrets.CHEF_ORG }}
          CHEF_USER: ${{ secrets.CHEF_USER }}
          CHEF_USER_KEY: ${{ secrets.CHEF_USER_KEY }}
          CHEF_SSL_VERIFY: ${{ secrets.CHEF_SSL_VERIFY }}
        run: |
          mkdir -p ~/.chef
          cat > ~/.chef/knife.rb <<'EOF'
          chef_server_url  ENV['CHEF_SERVER_URL']
          node_name        ENV['CHEF_USER']
          client_key       File.join(ENV['HOME'], '.chef', 'ci-user.pem')
          org_name         ENV['CHEF_ORG'] if ENV['CHEF_ORG']
          ssl_verify_mode  (ENV['CHEF_SSL_VERIFY'] || ':verify_peer')
          EOF
          printf '%s' "${CHEF_USER_KEY}" > ~/.chef/ci-user.pem
          chmod 600 ~/.chef/ci-user.pem

      - name: Resolve lockfile metadata
        id: meta
        run: |
          set -euo pipefail
          POLICYFILE="${{ matrix.policyfile }}"
          if [[ "$POLICYFILE" == *.rb ]]; then
            LOCKFILE_PATH="${POLICYFILE%.rb}.lock.json"
          else
            LOCKFILE_PATH="$POLICYFILE"
          fi
          SAFE_NAME="$(printf '%s' "$POLICYFILE" | tr '/.' '--' | tr -cd '[:alnum:]_-')"
          [ -n "$SAFE_NAME" ] || SAFE_NAME="policyfile"
          ARTIFACT_NAME="policy-lock-${SAFE_NAME}"
          echo "lockfile_path=$LOCKFILE_PATH" >> "$GITHUB_OUTPUT"
          echo "artifact_name=$ARTIFACT_NAME" >> "$GITHUB_OUTPUT"

      - name: Download lockfile artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ steps.meta.outputs.artifact_name }}
          path: .

      - name: Resolve downloaded lockfile path
        id: lock
        run: |
          set -euo pipefail
          EXPECTED_PATH="${{ steps.meta.outputs.lockfile_path }}"
          LOCK_BASENAME="$(basename "$EXPECTED_PATH")"
          if [ -f "$EXPECTED_PATH" ]; then
            FOUND="$EXPECTED_PATH"
          else
            FOUND="$(find . -type f -name "$LOCK_BASENAME" | head -n1 || true)"
          fi
          [ -n "$FOUND" ] || { echo "ERROR: Unable to locate lockfile artifact $LOCK_BASENAME"; exit 1; }
          echo "lockfile_path=$FOUND" >> "$GITHUB_OUTPUT"

      - name: Push policy to dev
        run: |
          set -euo pipefail
          echo "Pushing lockfile to dev: ${{ steps.lock.outputs.lockfile_path }}"
          chef push dev "${{ steps.lock.outputs.lockfile_path }}"

  push-test:
    name: Push Policy (test)
    needs: [push-dev, detect-policyfiles]
    if: needs.detect-policyfiles.outputs.policyfiles != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        policyfile: ${{ fromJson(needs.detect-policyfiles.outputs.policyfiles) }}
      fail-fast: false
    environment: test
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Chef Workstation
        run: |
          curl -L https://omnitruck.chef.io/install.sh | sudo bash -s -- -P chef-workstation -c stable
          echo "/opt/chef-workstation/bin" >> "$GITHUB_PATH"

      - name: Configure Chef Credentials
        env:
          CHEF_SERVER_URL: ${{ secrets.CHEF_SERVER_URL }}
          CHEF_ORG: ${{ secrets.CHEF_ORG }}
          CHEF_USER: ${{ secrets.CHEF_USER }}
          CHEF_USER_KEY: ${{ secrets.CHEF_USER_KEY }}
          CHEF_SSL_VERIFY: ${{ secrets.CHEF_SSL_VERIFY }}
        run: |
          mkdir -p ~/.chef
          cat > ~/.chef/knife.rb <<'EOF'
          chef_server_url  ENV['CHEF_SERVER_URL']
          node_name        ENV['CHEF_USER']
          client_key       File.join(ENV['HOME'], '.chef', 'ci-user.pem')
          org_name         ENV['CHEF_ORG'] if ENV['CHEF_ORG']
          ssl_verify_mode  (ENV['CHEF_SSL_VERIFY'] || ':verify_peer')
          EOF
          printf '%s' "${CHEF_USER_KEY}" > ~/.chef/ci-user.pem
          chmod 600 ~/.chef/ci-user.pem

      - name: Resolve lockfile metadata
        id: meta
        run: |
          set -euo pipefail
          POLICYFILE="${{ matrix.policyfile }}"
          if [[ "$POLICYFILE" == *.rb ]]; then
            LOCKFILE_PATH="${POLICYFILE%.rb}.lock.json"
          else
            LOCKFILE_PATH="$POLICYFILE"
          fi
          SAFE_NAME="$(printf '%s' "$POLICYFILE" | tr '/.' '--' | tr -cd '[:alnum:]_-')"
          [ -n "$SAFE_NAME" ] || SAFE_NAME="policyfile"
          ARTIFACT_NAME="policy-lock-${SAFE_NAME}"
          echo "lockfile_path=$LOCKFILE_PATH" >> "$GITHUB_OUTPUT"
          echo "artifact_name=$ARTIFACT_NAME" >> "$GITHUB_OUTPUT"

      - name: Download lockfile artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ steps.meta.outputs.artifact_name }}
          path: .

      - name: Resolve downloaded lockfile path
        id: lock
        run: |
          set -euo pipefail
          EXPECTED_PATH="${{ steps.meta.outputs.lockfile_path }}"
          LOCK_BASENAME="$(basename "$EXPECTED_PATH")"
          if [ -f "$EXPECTED_PATH" ]; then
            FOUND="$EXPECTED_PATH"
          else
            FOUND="$(find . -type f -name "$LOCK_BASENAME" | head -n1 || true)"
          fi
          [ -n "$FOUND" ] || { echo "ERROR: Unable to locate lockfile artifact $LOCK_BASENAME"; exit 1; }
          echo "lockfile_path=$FOUND" >> "$GITHUB_OUTPUT"

      - name: Push policy to test
        run: |
          set -euo pipefail
          echo "Pushing lockfile to test: ${{ steps.lock.outputs.lockfile_path }}"
          chef push test "${{ steps.lock.outputs.lockfile_path }}"

  push-prod:
    name: Push Policy (prod)
    needs: [push-test, detect-policyfiles]
    if: needs.detect-policyfiles.outputs.policyfiles != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        policyfile: ${{ fromJson(needs.detect-policyfiles.outputs.policyfiles) }}
      fail-fast: false
    environment: prod
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Chef Workstation
        run: |
          curl -L https://omnitruck.chef.io/install.sh | sudo bash -s -- -P chef-workstation -c stable
          echo "/opt/chef-workstation/bin" >> "$GITHUB_PATH"

      - name: Configure Chef Credentials
        env:
          CHEF_SERVER_URL: ${{ secrets.CHEF_SERVER_URL }}
          CHEF_ORG: ${{ secrets.CHEF_ORG }}
          CHEF_USER: ${{ secrets.CHEF_USER }}
          CHEF_USER_KEY: ${{ secrets.CHEF_USER_KEY }}
          CHEF_SSL_VERIFY: ${{ secrets.CHEF_SSL_VERIFY }}
        run: |
          mkdir -p ~/.chef
          cat > ~/.chef/knife.rb <<'EOF'
          chef_server_url  ENV['CHEF_SERVER_URL']
          node_name        ENV['CHEF_USER']
          client_key       File.join(ENV['HOME'], '.chef', 'ci-user.pem')
          org_name         ENV['CHEF_ORG'] if ENV['CHEF_ORG']
          ssl_verify_mode  (ENV['CHEF_SSL_VERIFY'] || ':verify_peer')
          EOF
          printf '%s' "${CHEF_USER_KEY}" > ~/.chef/ci-user.pem
          chmod 600 ~/.chef/ci-user.pem

      - name: Resolve lockfile metadata
        id: meta
        run: |
          set -euo pipefail
          POLICYFILE="${{ matrix.policyfile }}"
          if [[ "$POLICYFILE" == *.rb ]]; then
            LOCKFILE_PATH="${POLICYFILE%.rb}.lock.json"
          else
            LOCKFILE_PATH="$POLICYFILE"
          fi
          SAFE_NAME="$(printf '%s' "$POLICYFILE" | tr '/.' '--' | tr -cd '[:alnum:]_-')"
          [ -n "$SAFE_NAME" ] || SAFE_NAME="policyfile"
          ARTIFACT_NAME="policy-lock-${SAFE_NAME}"
          echo "lockfile_path=$LOCKFILE_PATH" >> "$GITHUB_OUTPUT"
          echo "artifact_name=$ARTIFACT_NAME" >> "$GITHUB_OUTPUT"

      - name: Download lockfile artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ steps.meta.outputs.artifact_name }}
          path: .

      - name: Resolve downloaded lockfile path
        id: lock
        run: |
          set -euo pipefail
          EXPECTED_PATH="${{ steps.meta.outputs.lockfile_path }}"
          LOCK_BASENAME="$(basename "$EXPECTED_PATH")"
          if [ -f "$EXPECTED_PATH" ]; then
            FOUND="$EXPECTED_PATH"
          else
            FOUND="$(find . -type f -name "$LOCK_BASENAME" | head -n1 || true)"
          fi
          [ -n "$FOUND" ] || { echo "ERROR: Unable to locate lockfile artifact $LOCK_BASENAME"; exit 1; }
          echo "lockfile_path=$FOUND" >> "$GITHUB_OUTPUT"

      - name: Push policy to prod
        run: |
          set -euo pipefail
          echo "Pushing lockfile to prod: ${{ steps.lock.outputs.lockfile_path }}"
          chef push prod "${{ steps.lock.outputs.lockfile_path }}"
